## This module provides type definitions for all structured report entries
## that compiler can provide.
##
## Note that this module specifically does not import anything else from
## the compiler - by design it is supposed to be available in every other
## module (because almost any phase of the compiler can generate reports
## one way or another). By design report should contain as much information
## as possible and *never* be used for any conditional logic in the
## compiler - it is a final form of the output that can only be printed to
## the output (either via user-provided report hook implementation, or
## using one of the built-in ones)
##
## Not using compiler-specific types also allows this report to be easily
## reused by external tooling - custom error pretty-printers, test runners
## and so on.

import std/[options]

type
  ReportKind* = enum
    ## Kinds of the toplevel reports. Only dispatches on report topics,
    ## such as sem, parse, macro (for `echo` in compile-time code) and so
    ## on. Subdivision is based on different phases of the compiler
    ## operation, and not on report's state itself, as those are completely
    ## orthogonal to each other (lexer might provide errors and hints,
    ## parser can provide errors, hints and warnings)

    repParser
    repLexer ## Report generated by lexer - bad tokens, lines that are too
             ## long etc.

    repSem ## Report produced directly by semantic analysis - compilation
           ## errors, warnings and hints

    repCmd ## Report related to execution of the external command - start
           ## of the command, execution failure, succes and so on.

    repDebug ## Side channel for the compiler debug report. Sem expansion
             ## traces and other helper messages designed specifically to
             ## aid development of the compiler


type
  ReportLineInfo* = object
    file*: string
    line*: int
    column*: int

  ReportBase* = object
    location*: Option[ReportLineInfo] ## Location associated with report.
    ## Some reports do not have any locations associated with them (most
    ## (but not all, due to `gorge`) of the external command executions,
    ## sem tracing etc). Some reports might have additional associated
    ## location information (view type sealing reasons) - those are handled
    ## on the per-report-kind basis.

    reportInst*: ReportLineInfo ## Information about instantiation location
    ## of the reports - present for all reports in order to track their
    ## origins.

type
  LexerReportKind* = enum
    rlexTest

  LexerReport* = object of ReportBase

type
  ParserReportKind* = enum
    rparTest

  ParserReport* = object of ReportBase

type
  SemReportKind* = enum
    rsemTest

  SemReport* = object of ReportBase

type
  CmdReportKind* = enum
    rcmdTest

  CmdReport* = object of ReportBase

type
  DebugReportKind* = enum
    rdbgTest

  DebugReport = object of ReportBase

type
  Report* = object
    ## Toplevel wrapper type for the compiler report
    case kind*: ReportKind
      of repLexer:
        lexReport*: LexerReport

      of repParser:
        parseReport*: ParserReport

      of repSem:
        semReport*: SemReport

      of repCmd:
        cmdReport*: CmdReport

      of repDebug:
        debugReport*: DebugReport
