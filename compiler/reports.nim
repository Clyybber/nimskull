## This module provides type definitions for all structured report entries
## that compiler can provide.
##
## Note that this module specifically does not import anything else from
## the compiler - by design it is supposed to be available in every other
## module (because almost any phase of the compiler can generate reports
## one way or another). By design report should contain as much information
## as possible and *never* be used for any conditional logic in the
## compiler - it is a final form of the output that can only be printed to
## the output (either via user-provided report hook implementation, or
## using one of the built-in ones)
##
## Not using compiler-specific types also allows this report to be easily
## reused by external tooling - custom error pretty-printers, test runners
## and so on.

import std/[options]

import ast_types, nilcheck_enums, int128

export
  ast_types,
  options.some,
  options.none,
  options.Option,
  int128.toInt128

type InstantiationInfo* = typeof(instantiationInfo())

const emptyReportId* = ReportId(0)

type
  ReportCategory* = enum
    ## Kinds of the toplevel reports. Only dispatches on report topics,
    ## such as sem, parse, macro (for `echo` in compile-time code) and so
    ## on. Subdivision is based on different phases of the compiler
    ## operation, and not on report's state itself, as those are completely
    ## orthogonal to each other (lexer might provide errors and hints,
    ## parser can provide errors, hints and warnings)

    repParser = "Parser"
    repLexer = "Lexer" ## Report generated by lexer - bad tokens, lines
    ## that are too long etc.

    repSem = "Sem" ## Report produced directly by semantic analysis -
    ## compilation errors, warnings and hints

    repCmd = "Cmd" ## Report related to execution of the external command -
    ## start of the command, execution failure, succes and so on.

    repDebug = "Debug" ## Side channel for the compiler debug report. Sem
    ## expansion traces and other helper messages designed specifically to
    ## aid development of the compiler

    repInternal = "Internal" ## Reports constructed during hanling of the
    ## internal compilation errors. Separate from debugging reports since
    ## they always exist - ICE, internal fatal errors etc.

    repBackend = "Backend" ## Backend-specific reports.

    repExternal = "External" ## Report constructed during handling of the
    ## external configuration, command-line flags, packages, modules.


  ReportKind* = enum
    ## Toplevel enum for different categories. Order of definitions is
    ## really important - elements are first separated into categories
    ## (internal reports, backend reports and so on) and can be further
    ## split into severity levels.
    ##
    ## Different naming scheme is used for a reports with different
    ## categories - this enum exists only to make it easier to work with
    ## different report kinds, without having to manage seven different
    ## enum types.

    repNone

    #--------------------------  Internal reports  ---------------------------#
    # Internal reports being
    # fatal errors begin
    rintUnknown ## Unknown internal report kind
    rintFatal ## Explicitly fatal compiler error

    rintUnreachable ## State in the compiler code that must not be reached
    rintAssert ## Failed internal assert in the compiler


    rintIce ## Internal compilation error
    # fatal end

    # errors being
    rintCannotOpenFile
    rintUsingLeanCompiler
    rintNotImplemented
    # errors end

    # warnings begin
    rintWarnCannotOpenFile
    rintWarnFileChanged
    # warnings end

    # hints start
    rintSource = "Source" ## Show source in the report
                          # REFACTOR this is a global configuration option,
                          # not a hint.


    rintGCStats = "GCStats" ## Print GC statistics for the compiler run
    rintQuitCalled = "QuitCalled" ## `quit()` called by the macro code
    rintStackTrace = "StackTrace" ## Stack trace during internal
    ## compilation error handling and similar
    rintMissingStackTrace ## Stack trace would've been generated in the
    ## debug compiler build
    rintMsgOrigin = "MsgOrigin"


    rintSuccessX ## Succesfull compilation
    # hints end

    rintNimconfWrite
    rintListWarnings
    rintListHints
    rintDumpState
    rintEchoMessage # last !

    # internal reports end

    #--------------------------  External reports  ---------------------------#
    # External reports
    # errors begin
    rextUnknownCCompiler

    # malformed cmdline parameters begin
    rextInvalidHint
    rextInvalidWarning
    rextInvalidCommandLineOption ## Invalid command-line option passed to
                                 ## the compiler
    rextOnlyAllOffSupported ## Only `all:off` is supported for mass
    ## hint/warning modification. Separate diagnostics must be enabled on
    ## one-by-one basis.
    rextExpectedOnOrOff ## Command-line option expected 'on' or 'off' value
    rextExpectedOnOrOffOrList ## Command-line option expected 'on', 'off'
    ## or 'list' value.
    rextExpectedCmdArgument ## Command-line option expected argument
    rextExpectedNoCmdArgument ## Command-line option expected no arguments
    rextInvalidNumber ## Command-line switch expected a number
    rextInvalidValue
    rextUnexpectedValue ## Command-line argument had value, but it did not
    ## match with any expected.

    rextIcUnknownFileName
    rextIcNoSymbolAtPosition

    rextExpectedTinyCForRun
    rextInvalidCommand
    rextCommandMissing
    rextExpectedRunOptForArgs
    rextUnexpectedRunOpt
    rextInvalidPath ## Invalid path for a command-line argument

    rextNimbleInvalidManifest
    rextNimbleInvalidSrcDir

    rextInvalidPackageName ## When adding packages from the `--nimbleDir`
    ## (or it's default value), names are validated. This error is
    ## generated if package name is not correct.
    # errors end

    # warnings begin
    rextDeprecated ## Report about use of the deprecated feature that is
    ## not in the semantic pass. Things like deprecated flags, compiler
    ## commands and so on.
    # warnings end

    # hints start
    rextConf = "Conf" ## Processing user configutation file
    rextPath = "Path" ## Add nimble path
    # hints end

    # external reports end

    #----------------------------  Lexer reports  ----------------------------#
    # Lexer report begin
    # errors begin
    rlexMalformedUnderscores
    rlexMalformedTrailingUnderscre
    rlexInvalidToken
    rlexNoTabs

    # numbers
    rlexInvalidIntegerPrefix
    rlexInvalidIntegerSuffix
    rlexNumberNotInRange
    rlexExpectedHex
    rlexInvalidIntegerLiteral

    # char
    rlexInvalidCharLiteral
    rlexMissingClosingApostrophe
    rlexInvalidUnicodeCodepoint

    # string
    rlexUnclosedTripleString
    rlexUnclosedSingleString

    rlexExpectedToken
    rlexCfgInvalidDirective

    # comments
    rlexUnclosedComment

    # errors end

    # warnings begin
    rlexDeprecatedOctalPrefix = "OctalEscape"
    rlexLinterReport
    # warnings end

    # hints begin
    rlexLineTooLong = "LineTooLong"

    rlexSyntaxesCode
    # hints end

    # Lexer report end

    #---------------------------  Parser reports  ----------------------------#
    # errors begin
    # regular nim parser
    rparInvalidIndentation
    rparNestableRequiresIndentation

    rparIdentExpected
    rparIdentOrKwdExpected
    rparExprExpected
    rparMissingToken
    rparUnexpectedToken
    rparUnexpectedTokenKind

    rparFuncNotAllowed
    rparTupleTypeWithPar
    rparMisplacedParameterVar
    rparConceptNotinType
    rparRotineExpected
    rparPragmaAlreadyPresent
    rparMisplacedExport

    # template parser `filter_tmpl.nim`
    rparTemplMissingEndClose
    rparTemplInvalidExpression

    rparInvalidFilter

    # erorrs end

    # warnings begin
    rparInconsistentSpacing = "Spacing"
    rparEnablePreviewDotOps = "DotLikeOps"
    rparPragmaNotFollowingTypeName
    rparPragmaBeforeGenericParameters
    # warnings end

    rparName = "Name" ## Linter report about used identifier

    #-----------------------------  Sem reports  -----------------------------#
    # semantic fatal
    rsemFatalError
    # end

    # Semantic errors begin
    rsemUserError = "UserError" ## `{.error: }`
    rsemUsageIsError

    rsemCustomError
    rsemCustomPrintMsgAndNodeError
      ## just like custom error, prints a message and renders wrongNode
    rsemTypeMismatch
    rsemTypeKindMismatch
    rsemAmbiguous
    rsemAmbiguousIdent

    rsemCustomUserError
      ## just like customer error, but reported as a errUser in msgs

    rsemNodeNotAllowed
      ## Generated in `filters.nim`

    rsemCannotProveNotNil
    rsemProvablyNil

    # nimsuggest
    rsemSugNoSymbolAtPosition

    # Global Errors
    rsemCustomGlobalError
      ## just like custom error, but treat it like a "raise" and fast track the
      ## "graceful" abort of this compilation run, used by `errorreporting` to
      ## bridge into the existing `msgs.liMessage` and `msgs.handleError`.

    # Module errors
    rsemSystemNeeds
    rsemInvalidModulePath
    rsemInvalidModuleName
    rsemCannotImportItself
    rsemRecursiveInclude
    rsemRecursiveImport
    rsemCannotOpenFile
    rsemExportRequiresToplevel
    rsemExperimentalRequiresToplevel
    rsemMethodRequiresToplevel
    rsemPackageRequiresToplevel
    rsemConverterRequiresToplevel
    rsemImportRequiresToplevel
    rsemUnexpectedToplevelDefer
    rsemUsingRequiresToplevel
    rsemInvalidVisibility
    rsemUnknownPackageName
    rsemUnexpectedInfixInInclude

    # ..
    rsemConflictingExportnims
    rsemNoMagicEqualsForType
    rsemCantConvertLiteralToType
    rsemCantConvertLiteralToRange
    rsemCantComputeOffsetof
    rsemStaticOutOfBounds ## Error generated when semfold or static bound
    ## checking sees and out-of-bounds index error.
    rsemStaticFieldNotFound # TODO DOC generated in `semfold.nim`, need
    # better documentation, right now I don't know what exactly this error
    # means and how to reproduce it in the example code.
    rsemSemfoldOverflow
    rsemSemfoldDivByZero
    rsemSemfoldInvalidConversion
    rsemInvalidIntdefine
    rsemInvalidBooldefine


    # Type definitions
    rsemCaseInUnion ## `{.union.}` type cannot use `case:` statements
    rsemOffsetInUnion ## `{.union.}` type cannot use inheritance and any
    ## other features that add implicit chunk of data before the actually
    ## listed fields.
    rsemUnexpectedInNewConcept
    rsemTooNestedConcept
    rsemIllegalRecursion
    rsemCannotInferStaticValue

    rsemVarVarNotAllowed ## `var lent`, `var var` etc. are not allowed in
    ## types
    rsemInvalidOrderInEnum
    rsemSetTooBig
    rsemTIsNotAConcreteType
    rsemProcIsNotAConcreteType
    rsemRangeIsEmpty

    rsemCannotInstantiate
    rsemCannotInstantiateWithParameter
    rsemCannotGenerateGenericDestructor
    rsemUndeclaredField
    rsemInheritanceOnlyWorksWithAnEnum # I have **//ABSOLUTELY NO IDEA//**
    # what this error means. I think I might need to add something like
    # `rsemWTF`
    rsemExpectedOrdinal
    rsemExpectedOrdinalOrFloat
    rsemExpectedUnholyEnum # yes
    rsemExpectedLow0Discriminant
    rsemExpectedHighCappedDiscriminant
    rsemMissingCaseBranches
    rsemRangeDoesNotSupportNan
    rsemRangeRequiresDotDot
    rsemExpectedRange
    rsemArrayExpectsPositiveRange
    rsemExpectObjectForBase
    rsemExpectNonFinalForBase

    rsemTVoidNotAllowed
    rsemExpectedObjectForRegion
    rsemUnexpectedVoidType
    rsemUnexpectedArrayAssignForCstring
    rsemMacroBodyDependsOnGenericTypes
    rsemMalformedNotNilType
    rsemEnableNotNilExperimental
    rsemEnableDotOperatorsExperimental
    rsemEnableCallOperatorExperimental
    rsemExpectedObjectType
    rsemExpectedImportedType
    rsemUnexpectedExportcInAlias
    rsemExpectedDistinctForBorrow
    rsemBorrowTargetNotFound
    rsemConceptInferenceFailed
    rsemConceptPredicateFailed

    # Procedure definition and instantiation
    rsemImplementationNotAllowed
    rsemImplementationExpected
    rsemRedefinitionOf
    rsemDefaultParamIsIncompatible
    rsemDeclarationVisibilityMismatch
    rsemGenericLambdaNowAllowed
    rsemUnexpectedAutoInForwardDeclaration
    rsemUnexpectedClosureOnToplevelProc
    rsemExpectedReturnTypeForIterator
    rsemExpectedReturnTypeForConverter
    rsemExpectedOneArgumentForConverter

    # Call and procedures
    rsemCallTypeMismatch
    rsemCallNotAProcOrField ## unknown or semantically invalid `obj.field`,
    ## `obj.call()`
    rsemExpressionCannotBeCalled
    rsemWrongNumberOfArguments
    rsemWrongNumberOfVariables
    rsemWrongNumberOfGenericParams
    rsemNoGenericParamsAllowed
    rsemAmbiguousCall
    rsemCallingConventionMismatch
    rsemHasSideEffects
    rsemCanHaveSideEffects
    rsemCantPassProcvar
    rsemUnlistedRaises
    rsemOverrideSafetyMismatch
    rsemOverrideLockMismatch
    rsemMissingMethodDispatcher
    rsemNotABaseMethod
    rsemIllegalCallconvCapture
    rsemIllegalMemoryCapture
    rsemIgnoreInvalidForLoop
    rsemMissingGenericParamsForTemplate
    rsemMisplacedMagicType
    rsemCannotInferParameterType
    rsemParameterRequiresAType
    rsemParameterRedefinition
    rsemInvalidExpression
    rsemExpectedNonemptyPattern

    rsemTemplateInstantiationTooNested
    rsemMacroInstantiationTooNested
    rsemGenericInstantiationTooNested # TODO write out list of generic,
    # macro or template instantiations. There is a `pushOwner` called for
    # each generic instantiation - can this be reused?

    rsemCannotSpawnProcWithVar
    rsemCannotSpawnMagicProc
    rsemCannotDiscardSpawn
    rsemSpawnRequiresCall
    rsemSpawnRequiresGcSafe
    rsemSpawnForbidsClosure
    rsemSpawnForbidsIterator

    rsemInvalidMethodDeclarationOrder # Right now I have no idea what this
    # error means exactly. It /does/ have a 'sort of' reproducible example
    # - https://github.com/nim-lang/Nim/issues/5325. No real tests for this
    # one of course, I mean who needs this, right?
    rsemIsNotParameterOf
    rsemParameterNotPointerToPartial

    # Statements
    rsemDiscardingVoid
    rsemDiscardingProc
    rsemInvalidControlFlow
    rsemContinueCannotHaveLabel
    rsemUseOrDiscard
    rsemCannotBeRaised
    rsemCannotRaiseNonException
    rsemExceptionAlreadyHandled
    rsemCannotExceptNativeAndImported
    rsemExpectedSingleFinally
    rsemExpectedSingleGeneralExcept
    rsemCannotConvertToRange
    rsemUsingRequiresType
    rsemUsingDisallowsAssign
    rsemDifferentTypeForReintroducedSymbol
    rsemImplicitFieldConstructinoRequiresPartial
    rsemCannotInferTypeOfLiteral
    rsemCannotInferTypeOfParameter
    rsemProcHasNoConcreteType
    rsemThreadvarCannotInit
    rsemLetNeedsInit
    rsemConstExpressionExpected
    rsemFieldsIteratorCannotContinue
    rsemParallelFieldsDisallowsCase
    rsemNoObjectOrTupleType
    rsemForExpectsIterator
    rsemSelectorMustBeOfCertainTypes
    rsemTypeCannotBeForwarded
    rsemDoubleCompletionOf
    rsemExpectedInvariantParam
    rsemCovariantUsedAsNonCovariant
    rsemContravariantUsedAsNonCovariant
    rsemNonInvariantCannotBeUsedWith
    rsemNonInvariantCnnnotBeUsedInConcepts
    rsemIncorrectResultProcSymbol
    rsemRebidingImplicitDestructor
    rsemRebidingDestructor
    rsemRebidingDeepCopy
    rsemInseparableTypeBoundOp
    rsemUnexpectedTypeBoundOpSignature
    rsemExpectedDestroyOrDeepCopyForOverride
    rsemExpectedObjectForMethod
    rsemUnexpectedPragmaInDefinitionOf
    rsemMisplacedRunnableExample

    # Expressions
    rsemConstantOfTypeHasNoValue
    rsemTypeConversionArgumentMismatch
    rsemUnexpectedEqInObjectConstructor
    rsemIllegalConversion
    rsemCannotBeConvertedTo
    rsemCannotCastToNonConcrete
    rsemCannotCastTypes
    rsemExpectedTypeOrValue
    rsemInvalidArgumentFor
    rsemNoTupleTypeForConstructor
    rsemInvalidTupleConstructor
    rsemUnknownIdentifier
    rsemIndexOutOfBounds
    rsemInvalidOrderInArrayConstructor
    rsemVarForOutParamNeeded
    rsemStackEscape
    rsemExprHasNoAddress
    rsemUnknownTrait
    rsemStringOrIdentNodeExpected
    rsemExpectedObjectForOf
    rsemCannotBeOfSubtype
    rsemQuantifierInRangeExpected
    rsemOldTakesParameterName
    rsemOldDoesNotBelongTo
    rsemCannotFindPlugin
    rsemExpectedProcReferenceForFinalizer
    rsemCannotIsolate
    rsemCannotInterpretNode
    rsemRecursiveDependencyIterator
    rsemIllegalNimvmContext
    rsemDisallowedNilDeref
    rsemInvalidTupleSubscript
    rsemLocalEscapesStackFrame
    rsemImplicitAddrIsNotFirstParam
    rsemExpectedOwnerReturn
    rsemExpectedUnownedRef
    rsemCannotAssignTo
    rsemNoReturnTypeDeclared
    rsemReturnNotAllowed
    rsemCannotInferReturnType
    rsemExpectedValueForYield
    rsemUnexpectedYield
    rsemCannotReturnTypeless
    rsemExpectedMacroOrTemplate
    rsemAmbiguousGetAst
    rsemExpectedTemplateWithNArgs
    rsemExpectedCallForGetAst
    rsemWrongNumberOfQuoteArguments
    rsemEnableExperimentalParallel
    rsemExpectedExpressionForSpawn
    rsemNamedExprExpected
    rsemNamedExprNotAllowed
    rsemFieldInitTwice
    rsemDisallowedTypedescForTupleField
    rsemDisjointFields
    rsemUnsafeRuntimeDiscriminantInit
    rsemConflictingDiscriminantInit
    rsemConflictingDiscriminantValues
    rsemRuntimeDiscriminantInitCap
    rsemRuntimeDiscriminantMustBeImmutable
    rsemRuntimeDiscriminantRequiresElif
    rsemObjectRequiresFieldInit
    rsemDistinctDoesNotHaveDefaultValue
    rsemExpectedModuleNameForImportExcept
    rsemCannotExport
    rsemCannotMixTypesAndValuesInTuple
    rsemExpectedTypelessDeferBody
    rsemInvalidBindContext
    rsemCannotCreateImplicitOpenarray
    rsemCannotAssignToDiscriminantWithCustomDestructor
    rsemUnavailableTypeBound

    rsemParallelInvalidControlFlow
    rsemParallelCannotProveDisjoint
    rsemParallelCounterAfterIncrement
    rsemParallelWithoutSpawn
    rsemSpawnInvalidContext

    # Identifier Lookup
    rsemUndeclaredIdentifier
    rsemExpectedIdentifier
    rsemExpectedIdentifierInExpr

    # Object and Object Construction
    rsemFieldNotAccessible
      ## object field is not accessible
    rsemFieldAssignmentInvalid
      ## object field assignment invalid syntax
    rsemFieldOkButAssignedValueInvalid
      ## object field assignment, where the field name is ok, but value is not
    rsemObjectConstructorIncorrect
      ## one or more issues encountered with object constructor

    # General Type Checks
    rsemExpressionHasNoType
      ## an expression has not type or is ambiguous

    rsemRawTypeMismatch

    rsemCannotConvertTypes
    rsemUnresolvedGenericParameter
    rsemCannotCreateFlowVarOfType
    rsemTypeNotAllowed

    # Literals
    rsemIntLiteralExpected
      ## int literal node was expected, but got something else
    rsemStringLiteralExpected
      ## string literal node was expected, but got something else

    rsemOnOrOffExpected
    rsemCallconvExpected
    rsemInnerCodeReordering
    rsemUnknownExperimental
    rsemDuplicateCaseLabel

    # view types
    rsemExpressionIsNotAPath
    rsemResultMustBorrowFirst
    rsemCannotDetermineBorrowTarget # TODO DOC need better explanation for
    # reasons of this error, right now it looks like a hacked-in check.
    rsemCannotBorrow
    rsemBorrowOutlivesSource
    rsemImmutableBorrowMutation

    # VM
    rsemVmOpcParseExpectedExpression
    rsemTooManyRegistersRequired
    rsemVmCannotFindBreakTarget
    rsemVmNotUnused
    rsemNotAFieldSymbol
    rsemVmTooLargetOffset
    rsemVmCannotGenerateCode
    rsemVmCannotCast
    rsemVmInvalidBindSym
    rsemVmBadExpandToAst
    rsemVmCannotEvaluateAtComptime
    rsemVmCannotImportc
    rsemVmEnableFFIToImportc
    rsemVmCannotCreateNullElement
    rsemVmInvalidObjectConstructor
    rsemVmNoClosureIterators
    rsemVmCannotCallMethod
    rsemVmCallingNonRoutine

    rsemVmStackTrace
    rsemTooManyIterations

    rsemMissingImportcCompleteStruct

    rsemCyclicTree
    rsemCyclicDependency
    rsemConstExprExpected

    # Codegen
    rsemRttiRequestForIncompleteObject
    rsemExpectedNimcallProc
    rsemExpectedExhaustiveCaseForComputedGoto
    rsemExpectedUnholyEnumForComputedGoto
    rsemTooManyEntriesForComputedGoto
    rsemExpectedLow0ForComputedGoto
    rsemExpectedCaseForComputedGoto
    rsemDisallowedRangeForComputedGoto
    rsemExpectedCallForCxxPattern
    rsemExpectedParameterForCxxPattern
    rsemExpectedLiteralForGoto
    rsemRequiresDeepCopyEnabled
    rsemDisallowedOfForPureObjects
    rsemDisallowedReprForNewruntime
    rsemCannotCodegenCompiletimeProc

    # Pragma
    rsemInvalidPragma
      ## suplied pragma is invalid
    rsemCannotAttachPragma
    rsemUnexpectedPragma
    rsemPropositionExpected
    rsemIllegalCustomPragma
      ## supplied pragma is not a legal custom pragma, and cannot be attached
    rsemNoReturnHasReturn
      ## a routine marked as no return, has a return type
    rsemImplicitPragmaError
      ## a symbol encountered an error when processing implicit pragmas, this
      ## should be applied to symbols and treated as a wrapper for the purposes
      ## of reporting. the original symbol is stored as the first argument
    rsemPragmaDynlibRequiresExportc
      ## much the same as `ImplicitPragmaError`, except it's a special case
      ## where dynlib pragma requires an importc pragma to exist on the same
      ## symbol
      ## xxx: pragmas shouldn't require each other, that's just bad design

    rsemWrappedError
      ## there is no meaningful error to construct, but there is an error
      ## further down the AST that invalidates the whole

    rsemSymbolKindMismatch
    rsemIllformedAst
    rsemInitHereNotAllowed
    rsemIdentExpected
    rsemTypeExpected
    rsemGenericTypeExpected
    rsemTypeInvalid
    rsemWrongIdent
    rsemPragmaOptionExpected
    rsemUnexpectedPushArgument
    rsemCannotPushCast
    rsemCastRequiresStatement
    rsemExportcppRequiresCpp
    rsemDynlibRequiresExportc
    rsemImportjsRequiresJs
    rsemImportjsRequiresPattern
    rsemBitsizeRequires1248
    rsemBitsizeRequiresPositive
    rsemAlignRequiresPowerOfTwo
    rsemPragmaRecursiveDependency
    rsemMisplacedDeprecation
    rsemNoUnionForJs

    rsemThisPragmaRequires01Args
    rsemMismatchedPopPush
    rsemExcessiveCompilePragmaArgs
    rsemLinePragmaExpectsTuple
    rsemRaisesPragmaExpectsObject

    # -- locking
    rsemLocksPragmaExpectsList
    rsemLocksPragmaBadLevel
    rsemLocksRequiresArgs
    rsemMultilockRequiresSameLevel
    rsemInvalidNestedLocking
    rsemUnguardedAccess
    rsemInvalidGuardField

    rsemDrNimRequiresUsesMissingResult
    rsemDrnimCannotProveLeq
    rsemDrnimCannotPorveGe

    rsemBorrowPragmaNonDot
    rsemInvalidExtern
    rsemInvalidPragmaBlock
    rsemBadDeprecatedArgs
    rsemMisplacedEffectsOf
    rsemMissingPragmaArg
    rsemErrGcUnsafe
    rsemEmptyAsm


    # end

    # Semantic warnings begin
    rsemUserWarning            = "User" ## `{.warning: }`
    rsemUnknownMagic           = "UnknownMagic"
    rsemUnusedImport           = "UnusedImport"
    rsemDeprecated             = "Deprecated"
    rsemLockLevelMismatch      = "LockLevel"

    rsemDotForModuleImport
    rsemReorderingFail
    rsemProveField             = "ProveField"
    rsemStrictNotNil           = "StrictNotNil"
    rsemWarnGcUnsafe           = "GcUnsafe"
    rsemGcUnsafeListing
    rsemProveInit              = "ProveInit"
    rsemUninit                 = "Uninit"
    rsemWarnUnsafeCode         = "UnsafeCode"
    rsemImplicitCstringConvert = "CStringConv"
    rsemHoleEnumConvert        = "HoleEnumConv"
    rsemAnyEnumConvert         = "AnyEnumConv"
    rsemUnusedRaises           = "Effect"
    rsemMethodLockMismatch
    rsemUseBase                = "UseBase"
    rsemUnreachableElse        = "UnreachableElse"
    rsemUnreachableCode        = "UnreachableCode"
    rsemInheritFromException   = "InheritFromException"
    rsemPtrRegionIsDeprecated
    rsemTypedReturnDeprecated
    rsemEachIdentIsTuple       = "EachIdentIsTuple"
    rsemResultShadowed         = "ResultShadowed"
    rsemResultUsed             = "ResultUsed"
    rsemGenericMethodsDeprecated
    rsemSuspiciousEnumConv     = "EnumConv"
    rsemUnsafeSetLen           = "UnsafeSetLen"
    rsemUnsafeDefault          = "UnsafeDefault"
    rsemBindDeprecated
    rsemUncollectableRefCycle  =  "CycleCreated"
    rsemParallelWarnCannotProve
    rsemParallelWarnCanProve
    rsemParallelWarnNotDisjoint
    rsemObservableStores       = "ObservableStores"
    rsemCaseTransition         = "CaseTransition"
    rsemUseOfGc                = "GcMem"

    rsemLinterReport # last !
    # end

    # Semantic hints begin
    rsemUserHint = "UserHint" ## `{.hint: .}` pragma encountereed
    rsemHintLibDependency
    rsemXDeclaredButNotUsed = "XDeclaredButNotUsed"
    rsemDuplicateModuleImport = "DuplicateModuleImport"
    rsemXCannotRaiseY = "XCannotRaiseY"
    rsemConvToBaseNotNeeded = "ConvToBaseNotNeeded"
    rsemConvFromXtoItselfNotNeeded = "ConvFromXtoItselfNotNeeded"

    rsemProcessing = "Processing" ## Processing module
    rsemProcessingStmt = "ProcessingStmt" ## Processing toplevel statement

    rsemExprAlwaysX = "ExprAlwaysX" ## Expression always evaluates to "X"
    rsemConditionAlwaysTrue = "CondTrue" ## Condition is always true
    rsemConditionAlwaysFalse = "CondFalse" ## Condition is always false

    rsemPattern = "Pattern" ## Term rewriting pattern has been triggered
    rsemCannotMakeSink ## Argument could not be turned into a sink
                       ## parameter. Generated once in the whole compiler
                       ## `sinkparameter_inference.nim`
    rsemCopiesToSink ## Passing data to the `sink` parameter still copies
                     ## due to control flow in the code

    rsemGlobalVar = "GlobalVar" ## Track global variable declarations?

    rsemEffectsListingHint
    rsemPreExpandMacro
    rsemPostExpandMacro
    rsemExpandMacro = "ExpandMacro" ## Trace macro expansion progress
    rsemExpandArc = "ExpandArc"


    rsemNonMatchingCandidates
    rsemUserRaw = "UserRaw" # REVIEW - Used in
    # `semcall.semOverloadedCall()` and `extccomp.getCompileCFileCmd()`.
    # Seems like this one should be removed, it spans multiple compiler
    # subsystems. Can't understand what it is doing.

    rsemExtendedContext = "ExtendedContext" ## Extended contextual
    ## information. Used in `ccgstmts.genStmts()` and
    ## `semexprs.semExprNoType()`
    rsemImplicitObjConv = "ImplicitObjConv"
    # end

    #------------------------  Command report kinds  -------------------------#
    # errors
    rcmdFailedExecution
    # errors end

    # hints
    rcmdCC
    rcmdExecuting
    rcmdRunnableExamplesSuccess
    # hints end


    #----------------------------  Debug reports  ----------------------------#
    rdbgTest
    rdbgOptionsPush
    rdbgOptionsPop

    #---------------------------  Backend reports  ---------------------------#
    # errors start
    rbackCannotWriteScript ## Cannot write build script to a cache file
    rextExpectedCbackendForRun
    rbackCannotWriteMappingFile ## Canot write module compilation mapping
    ## file to cache directory
    rbackTargetNotSupported ## C compiler does not support requested target
    rbackJsTooCaseTooLarge
    rbackJsUnsupportedClosureIter
    rbackJsonScriptMismatch # ??? used in `extccomp.nim`, TODO figure out
    # what the original mesage was responsible for exactly

    rbackRstCannotOpenFile
    rbackRstExpected
    rbackRstGridTableNotImplemented
    rbackRstMarkdownIllformedTable
    rbackRstNewSectionExpected
    rbackRstGeneralParseError
    rbackRstInvalidDirective
    rbackRstInvalidField
    rbackRstFootnoteMismatch

    rbackCannotProduceAssembly
    # errors end

    # warnings start
    rbackRstTestUnsupported
    rbackRstRedefinitionOfLabel = "RedefinitionOfLabel"
    rbackRstUnknownSubstitution = "UnknownSubstitutionX"
    rbackRstBrokenLink          = "BrokenLink"
    rbackRstUnsupportedLanguage = "LanguageXNotSupported"
    rbackRstUnsupportedField    = "FieldXNotSupported"
    rbackRstRstStyle            =  "warnRstStyle"

    # warnings end

    # hints start
    rbackProducedAssembly

    rbackLinking
    rbackCompilingExtraFile ## Compiling file specified in the
    ## `{.compile:.}` pragma


    rbackUseDynLib ## Use of the dynamic library for cgen. Used in the
    ## `cgen.loadDynamicLib`
    # hints end

  ReportKinds* = set[ReportKind]

const rstWarnings* = {rbackRstTestUnsupported .. rbackRstRstStyle}

static:
  echo(
    "Nimskull compiler outputs ",
    ord(high(ReportKind)),
    " different kinds of diagnostics")

type
  ReportLineRange* = object
    ## Report location expressed as a span of lines in the file
    file*: string
    startLine*, endline*: int
    startCol*, endCol*: int

  ReportLinePoint* = object
    ## Location expressed in terms of a single point in the file
    file*: string
    line*, col*: int

  ReportLineInfo* = object
    case isRange*: bool
      of true:
        lrange*: ReportLineRange

      of false:
        lpoint*: ReportLinePoint

  ReportSeverity* = enum
    rsevDebug = "Debug" ## Internal compiler debug information

    rsevHint = "Hint" ## User-targeted hint
    rsevWarning = "Warning" ## User-targeted warnings
    rsevError = "Error" ## User-targeted error

    rsevFatal = "Fatal"
    rsevTrace = "Trace" ## Additional information about compiler actions -
    ## external commands mostly.

  ReportContextKind* = enum
    sckInstantiationOf
    sckInstantiationFrom


  ReportContext* = object
    location*: ReportLinePoint ## Report context instantiation
    case kind*: ReportContextKind
      of sckInstantiationOf:
        entry*: PSym ## Instantiated entry symbol

      of sckInstantiationFrom:
        discard

  ReportBase* = object of RootObj
    context*: seq[ReportContext]

    location*: Option[ReportLineInfo] ## Location associated with report.
    ## Some reports do not have any locations associated with them (most
    ## (but not all, due to `gorge`) of the external command executions,
    ## sem tracing etc). Some reports might have additional associated
    ## location information (view type sealing reasons) - those are handled
    ## on the per-report-kind basis.

    reportInst*: ReportLinePoint ## Information about instantiation location
    ## of the reports - present for all reports in order to track their
    ## origins.

type
  LexerReportKind* = range[rlexMalformedUnderscores .. rlexSyntaxesCode]
  LexerReport* = object of ReportBase
    msg*: string
    case kind*: ReportKind
      of rlexLinterReport:
        wanted*: string
        got*: string

      else:
        discard


const
  rlexHintKinds*    = {rlexLineTooLong .. rlexSyntaxesCode}
  rlexWarningKinds* = {rlexDeprecatedOctalPrefix .. rlexLinterReport}
  rlexErrorKinds*   = {rlexMalformedUnderscores .. rlexUnclosedComment}

func severity*(rep: LexerReport): ReportSeverity =
  case rep.kind:
    of rlexHintKinds: rsevHint
    else: rsevTrace

type
  ParserReportKind* = range[rparInvalidIndentation .. rparName]
  ParserReport* = object of ReportBase
    msg*: string
    found*: string
    case kind*: ReportKind
      of rparIdentExpected .. rparUnexpectedToken:
        expected*: seq[string]

      of rparInvalidFilter:
        node*: PNode

      else:
        discard



const
  rparHintKinds*    = {rparName}
  rparErrorKinds*   = {rparInvalidIndentation .. rparInvalidFilter}
  rparWarningKinds* = {
    rparInconsistentSpacing .. rparPragmaBeforeGenericParameters}

func severity*(parser: ParserReport): ReportSeverity =
  case parser.kind:
    of rparHintKinds: rsevHint
    else: rsevTrace

const
  rsemReportTwoSym* = {
    rsemConflictingExportnims,
  }

  rsemReportOneSym* = {
    rsemDeprecated,
    rsemRedefinitionOf,
    rsemUnexpectedPragmaInDefinitionOf,
    rsemDoubleCompletionOf,
    rsemInvalidMethodDeclarationOrder,

    rsemIllegalCallconvCapture,
    rsemIllegalMemoryCapture,
    rsemBorrowOutlivesSource,
    rsemImmutableBorrowMutation,
    rsemOverrideSafetyMismatch,
    rsemOverrideLockMismatch
  }

  rsemReportListSym* = {
    rsemAmbiguous,
    rsemAmbiguousIdent,
    rsemMissingCaseBranches,
    rsemObjectRequiresFieldInit
  }

  rsemReportCountMismatch* = {
    rsemWrongNumberOfArguments,
    rsemWrongNumberOfGenericParams,
    rsemInvalidOrderInEnum,
    rsemSetTooBig,
    rsemArrayExpectsPositiveRange,
    rsemExpectedLow0Discriminant,
    rsemInvalidOrderInArrayConstructor,
    rsemTypeConversionArgumentMismatch,
    rsemInvalidTupleSubscript,
    rsemExpectedTemplateWithNArgs,
    rsemExpectedParameterForCxxPattern,
    rsemWrongNumberOfQuoteArguments,
    rsemIndexOutOfBounds,
    rsemExpectedHighCappedDiscriminant
  }

type
  SemReportKind* = range[rsemUserError .. rsemImplicitObjConv]
  SemReportErrorKind* = range[rsemUserError .. rsemWrappedError]

  SemGcUnsafetyKind* = enum
    sgcuCallsUnsafe
    sgcuAccessesGcGlobal
    sgcuIndirectCallVia
    sgcuIndirectCallHere

  SemSideEffectCallKind* = enum
    ssefUsesGlobalState
    ssefCallsSideEffect
    ssefCallsViaHiddenIndirection
    ssefCallsViaIndirection
    ssefParameterMutation

  SemTypeMismatch* = object
    formalTypeKind*: set[TTypeKind]
    actualType*, formalType*: PType
    descriptionStr*: string

  SemCallDiagnosticsKind* = enum
    scalldDefaultParamIsIncompatible

  SemCallDiagnostics* = object
    case kind*: SemCallDiagnosticsKind
      of scalldDefaultParamIsIncompatible:
        param*: PSym

  SemCallMismatch* = object
    ## Description of the single candidate mismatch. This type is later
    ## used to construct meaningful type mismatch message, and must contain
    ## all the necessary information to provide meaningful sorting,
    ## collapse and other operations.
    target*: PSym ## Procedure that was tried for an overload resolution
    expression*: PNode ## Full typed expression that was used as a
    ## procedure call
    arg*: int ## Mismatched argument index. This corresponds to the
    ## *expression* subnode index - due to varargs actual *target
    ## parameter* index might differe. See `.formal` field for the actual
    ## target argument symbol.
    targetArg*: PSym ## parameter that mismatches against provided
    ## argument its position can differ from `arg` because of varargs
    diagnostics*: seq[SemCallDiagnostics]
    case kind*: MismatchKind
      of kTypeMismatch:
        typeMismatch*: SemTypeMismatch ## Argument type mismatch
                                       ## elaboration

      of kPositionalAlreadyGiven, kUnknownNamedParam,
         kAlreadyGiven, kMissingParam:
        ## Parameter name (if used) is stored in the `.targetArg` symbol
        discard

      else:
        discard

  SemSpellCandidate* = object
    dist*: int
    depth*: int
    sym*: PSym
    isLocal*: bool

  SemReport* = object of ReportBase
    ast*: PNode
    typ*: PType
    sym*: PSym
    str*: string
    spellingCandidates*: seq[SemSpellCandidate]

    case kind*: ReportKind
      of rsemDuplicateModuleImport:
        previous*: ReportLinePoint

      of rsemUnavailableTypeBound:
        missingTypeBoundElaboration*: tuple[
          anotherRead: Option[ReportLinePoint],
          tryMakeSinkParam: bool
        ]

      of rsemDuplicateCaseLabel:
        overlappingGroup*: PNode

      of rsemCannotBorrow:
        borrowPair*: tuple[mutatedHere, connectedVia: ReportLinePoint]

      of rsemXCannotRaiseY:
        raisesList*: PNode

      of rsemStrictNotNil:
        nilIssue*: Nilability
        nilHistory*: seq[tuple[
          node: PNode,
          nilability: Nilability,
          info: ReportLinePoint,
          transition: NilTransition
        ]]

      of rsemGcUnsafeListing:
        gcUnsafeTrace*: seq[tuple[
          isUnsafe: PSym,
          unsafeVia: PSym,
          unsafeRelation: SemGcUnsafetyKind,
          location: ReportLinePoint
        ]]

      of rsemHasSideEffects:
        sideEffectTrace*: seq[tuple[
          isUnsafe: PSym,
          unsafeVia: PSym,
          trace: SemSideEffectCallKind,
          location: ReportLinePoint
        ]]

        sideEffectMutateConnection*: ReportLinePoint

      of rsemEffectsListingHint:
        effectListing*: tuple[tags, exceptions: seq[PType]]

      of rsemVmStackTrace:
        traceReason*: ReportKind
        stacktrace*: seq[tuple[
          sym: PSym,
          location: ReportLinePoint
        ]]

      of rsemReportCountMismatch:
        countMismatch*: tuple[expected, got: Int128]

      of rsemInvalidExtern:
        externName*: string

      of rsemWrongIdent:
        expectedIdents*: seq[string]

      of rsemDrnimCannotProveLeq, rsemDrnimCannotPorveGe:
        drnimExpressions*: tuple[a, b: PNode]

      of rsemExprHasNoAddress:
        isUnsafeAddr*: bool

      of rsemUndeclaredIdentifier,
         rsemCallNotAProcOrField,
           :
        potentiallyRecursive*: bool

        explicitCall*: bool ## Whether `rsemCallNotAProcOrField` error was
        ## caused by expression with explicit dot call: `obj.cal()`
        unexpectedCandidate*: seq[PSym] ## Symbols that are syntactically
        ## valid in this context, but semantically are not allowed - for
        ## example `object.iterator()` call outside of the `for` loop.

      of rsemDisjointFields,
         rsemUnsafeRuntimeDiscriminantInit,
         rsemConflictingDiscriminantInit,
         rsemConflictingDiscriminantValues:
        fieldMismatches*: tuple[first, second: seq[PSym]]

      of rsemReportTwoSym + rsemReportOneSym + rsemReportListSym:
        symbols*: seq[PSym]

      of rsemExpandMacro, rsemPattern, rsemExpandArc:
        expandedAst*: PNode

      of rsemLockLevelMismatch, rsemMethodLockMismatch:
        anotherMethod*: PSym
        lockMismatch*: tuple[expected, got: string]

      of rsemTypeMismatch,
         rsemSuspiciousEnumConv,
         rsemTypeKindMismatch,
         rsemSemfoldInvalidConversion,
         rsemCannotConvertTypes,
         rsemImplicitObjConv,
         rsemVmCannotCast,
         rsemIllegalConversion,
         rsemConceptInferenceFailed,
         rsemCannotInstantiateWithParameter,
         rsemCannotCastTypes,
         rsemGenericTypeExpected,
         rsemCannotBeOfSubtype,
         rsemDifferentTypeForReintroducedSymbol:
        typeMismatch*: seq[SemTypeMismatch]

      of rsemSymbolKindMismatch:
        expectedSymbolKind*: set[TSymKind]

      of rsemTypeNotAllowed:
        allowedType*: tuple[
          allowed: PType,
          actual: PType,
          kind: TSymKind,
          allowedFlags: TTypeAllowedFlags
        ]

      of rsemCallTypeMismatch, rsemNonMatchingCandidates:
        callMismatches*: seq[SemCallMismatch] ## Description of all the
        ## failed candidates.

      of rsemStaticOutOfBounds:
        indexSpec*: tuple[usedIdx, minIdx, maxIdx: Int128]



      of rsemProcessing:
        processing*: tuple[
          isNimscript: bool,
          importStackLen: int,
          fromModule: string,
          isToplevel: bool,
          moduleStatus, path: string
        ]

      of rsemLinterReport:
        linterFail*: tuple[wanted, got: string]

      else:
        discard

const
  rsemErrorKinds* = {rsemUserError .. rsemEmptyAsm}
  rsemWarningKinds* = {rsemUserWarning .. rsemLinterReport}
  rsemHintKinds* = {rsemUserHint .. rsemImplicitObjConv}

func severity*(report: SemReport): ReportSeverity =
  case report.kind:
    of rsemErrorKinds: result = rsevError
    of rsemWarningKinds: result = rsevWarning
    of rsemHintKinds: result = rsevHint
    else: assert false

func reportSymbols*(
    kind: ReportKind,
    symbols: seq[PSym],
    typ: PType = nil,
    ast: PNode = nil
  ): SemReport =
  case kind:
    of rsemReportTwoSym: assert symbols.len == 2
    of rsemReportOneSym: assert symbols.len == 1
    of rsemReportListSym: discard
    else: assert false, $kind

  result = SemReport(kind: kind, ast: ast)
  result.symbols = symbols
  result.typ = typ

func reportSem*(kind: ReportKind): SemReport = SemReport(kind: kind)

func reportAst*(
    kind: ReportKind,
    ast: PNode, str: string = "", typ: PType = nil, sym: PSym = nil
  ): SemReport =

  SemReport(kind: kind, ast: ast, str: str, typ: typ, sym: sym)

func reportTyp*(
    kind: ReportKind,
    typ: PType, ast: PNode = nil, sym: PSym = nil, str: string = ""
  ): SemReport =
  SemReport(kind: kind, typ: typ, ast: ast, sym: sym, str: str)

func reportStr*(
    kind: ReportKind,
    str: string, ast: PNode = nil, typ: PType = nil, sym: PSym = nil
  ): SemReport =

  SemReport(kind: kind, ast: ast, str: str, typ: typ, sym: sym)

func reportSym*(
    kind: ReportKind,
    sym: PSym, ast: PNode = nil, str: string = "", typ: PType = nil,
  ): SemReport =

  SemReport(kind: kind, ast: ast, str: str, typ: typ, sym: sym)

template withIt*(expr: untyped, body: untyped): untyped =
  block:
    var it {.inject.} = expr
    body
    it

type
  CmdReportKind* = range[rcmdFailedExecution .. rcmdRunnableExamplesSuccess]
  CmdReport* = object of ReportBase
    cmd*: string
    msg*: string
    code*: int
    case kind*: ReportKind
      of rcmdFailedExecution:
        exitOut*, exitErr*: string

      of rcmdCC:
        packageName*: string

      else:
        discard

const
  rcmdErrorKinds* = {rcmdFailedExecution}
  rcmdWarningKinds* = default(set[ReportKind])
  rcmdHintKinds* = {rcmdCC .. rcmdRunnableExamplesSuccess}

func severity*(report: CmdReport): ReportSeverity =
  rsevTrace

type
  DebugReportKind* = range[rdbgTest .. rdbgOptionsPop]

  DebugReport* = object of ReportBase
    case kind*: ReportKind
      of rdbgOptionsPush, rdbgOptionsPop:
        optionsNow*: TOptions

      else:
        discard

func severity*(report: DebugReport): ReportSeverity =
  rsevDebug

type
  BackendReportKind* = range[rbackCannotWriteScript .. rbackUseDynLib]
  BackendReport* = object of ReportBase
    msg*: string
    usedCompiler*: string
    case kind*: ReportKind
      of rbackCannotWriteScript,
         rbackProducedAssembly,
         rextExpectedCbackendForRun,
         rbackCannotWriteMappingFile:
        filename*: string

      of rbackTargetNotSupported:
        requestedTarget*: string

      of rbackJsonScriptMismatch:
        jsonScriptParams*: tuple[
          outputCurrent, output, jsonFile: string]

      else:
        discard

const
  rbackErrorKinds* = {rbackCannotWriteScript}

func severity*(report: BackendReport): ReportSeverity =
  case report.kind:
    of rbackErrorKinds: rsevError
    else: rsevTrace

type
  ExternalReportKind* = range[rextUnknownCCompiler .. rextPath]
  ExternalReport* = object of ReportBase
    ## Report about external environment reads, passed configuration
    ## options etc.
    msg*: string

    case kind*: ReportKind
      of rextInvalidHint .. rextInvalidPath:
        cmdlineSwitch*: string ## Switch in processing
        cmdlineProvided*: string ## Value passed to the command-line
        cmdlineAllowed*: seq[string] ## Allowed command-line values
        cmdlineError*: string ## Textual description of the cmdline failure

      of rextUnknownCCompiler:
        knownCompilers*: seq[string]
        passedCompiler*: string

      of rextInvalidPackageName:
        packageName*: string

      of rextPath:
        packagePath*: string

      else:
        discard

const
  rextErrorKinds* = {rextUnknownCCompiler .. rextInvalidPackageName}
  rextWarningKinds* = {rextDeprecated}
  rextHintKinds* = {rextConf .. rextPath}

func severity*(report: ExternalReport): ReportSeverity =
  case report.kind:
    of rextErrorKinds: rsevError
    of rextWarningKinds: rsevWarning
    of rextHintKinds: rsevHint
    else: rsevTrace

type
  InternalReportKind* = range[rintUnknown .. rintEchoMessage]

  UsedBuildParams* = object
    project*: string
    output*: string
    mem*: int
    isMaxMem*: bool
    sec*: float
    case isCompilation*: bool
      of true:
        threads*: bool
        backend*: string
        buildMode*: string
        optimize*: string
        gc*: string

      of false:
        discard

  InternalStateDump* = ref object
    version*: string
    nimExe*: string
    prefixdir*: string
    libpath*: string
    project_path*: string
    defined_symbols*: seq[string]
    lib_paths*: seq[string]
    lazyPaths*: seq[string]
    nimbleDir*: string
    outdir*: string
    `out`*: string
    nimcache*: string
    hints*, warnings*: seq[tuple[name: string, enabled: bool]]

  InternalReport* = object of ReportBase
    ## Report generated for the internal compiler workings
    msg*: string
    case kind*: ReportKind
      of rintStackTrace:
        trace*: seq[StackTraceEntry] ## Generated stack trace entries

      of rintDumpState:
        stateDump*: InternalStateDump

      of rintAssert:
        expression*: string

      of rintSuccessX:
        buildParams*: UsedBuildParams

      of rintCannotOpenFile .. rintWarnFileChanged:
        file*: string

      of rintListWarnings, rintListHints:
        enabledOptions*: set[ReportKind]

      else:
        discard

const
  repInternalKinds*: ReportKinds = {
    low(InternalReportKind) .. high(InternalReportKind)}

  rintFatalKinds* = {rintUnknown .. rintIce} ## Fatal internal compilation
                                             ## reports
  rintErrorKinds* = {rintCannotOpenFile .. rintNotImplemented}
  rintWarningKinds* = {rintWarnCannotOpenFile .. rintWarnFileChanged}
  rintHintKinds* = {rintSource .. rintSuccessX}

func severity*(report: InternalReport): ReportSeverity =
  case report.kind:
    of rintFatalKinds: rsevFatal
    else: rsevTrace

const
  repWarningKinds*: ReportKinds =
    rsemWarningKinds +
      rlexWarningKinds +
      rparWarningKinds +
      rextWarningKinds +
      rcmdWarningKinds +
      rintWarningKinds

  repHintKinds*: ReportKinds    =
    rsemHintKinds +
      rlexHintKinds +
      rparHintKinds +
      rextHintKinds +
      rcmdHintKinds +
      rintHintKinds

  repErrorKinds*: ReportKinds   =
    rsemErrorKinds +
      rlexErrorKinds +
      rparErrorKinds +
      rextErrorKinds +
      rcmdErrorKinds +
      rintErrorKinds

  repFatalKinds*: ReportKinds = rintFatalKinds


type
  ReportTypes* =
    LexerReport    |
    ParserReport   |
    SemReport      |
    CmdReport      |
    DebugReport    |
    InternalReport |
    BackendReport  |
    ExternalReport

  Report* = object
    ## Toplevel wrapper type for the compiler report
    case category*: ReportCategory
      of repLexer:
        lexReport*: LexerReport

      of repParser:
        parserReport*: ParserReport

      of repSem:
        semReport*: SemReport

      of repCmd:
        cmdReport*: CmdReport

      of repDebug:
        debugReport*: DebugReport

      of repInternal:
        internalReport*: InternalReport

      of repBackend:
        backendReport*: BackendReport

      of repExternal:
        externalReport*: ExternalReport

static:
  echo "Size of the report object is ", sizeof(Report)
  echo "Sem report: ", sizeof(SemReport)

let reportEmpty* = Report(
  category: repInternal,
  internalReport: InternalReport(kind: repNone))


template eachCategory*(report: Report, field: untyped): untyped =
  case report.category:
    of repLexer:    report.lexReport.field
    of repParser:   report.parserReport.field
    of repCmd:      report.cmdReport.field
    of repSem:      report.semReport.field
    of repDebug:    report.debugReport.field
    of repInternal: report.internalReport.field
    of repBackend:  report.backendReport.field
    of repExternal: report.externalReport.field

func kind*(report: Report): ReportKind = eachCategory(report, kind)
func location*(report: Report): Option[ReportLineInfo] = eachCategory(report, location)
func reportInst*(report: Report): ReportLinePoint = eachCategory(report, reportInst)

func severity*(
    report: ReportTypes,
    asError: ReportKinds,
    asWarning: ReportKinds = default(ReportKinds)
  ): ReportSeverity =

  if report.kind in asError:
    rsevError

  elif report.kind in asWarning:
    rsevWarning

  else:
    severity(report)



func severity*(
    report: Report,
    asError: ReportKinds = default(ReportKinds),
    asWarning: ReportKinds = default(ReportKinds)
  ): ReportSeverity =
  ## Return report severity accounting for 'asError' and 'asWarning'
  ## mapping sets.

  if report.kind in asError: rsevError
  elif report.kind in asWarning: rsevWarning
  else:
    case report.category:
      of repLexer:    report.lexReport.severity()
      of repParser:   report.parserReport.severity()
      of repSem:      report.semReport.severity()
      of repCmd:      report.cmdReport.severity()
      of repInternal: report.internalReport.severity()
      of repBackend:  report.backendReport.severity()
      of repDebug:    report.debugReport.severity()
      of repExternal: report.externalReport.severity()

func toReportLinePoint*(iinfo: InstantiationInfo): ReportLinePoint =
  ReportLinePoint(file: iinfo[0], line: iinfo[1], col: iinfo[2])

template reportHere*[R: ReportTypes](report: R): R =
  block:
    var tmp = report
    tmp.reportInsta = toReportLinePoint(
      instantiationInfo(fullPaths = true))

    tmp

func wrap*(rep: sink LexerReport): Report =
  assert rep.kind in {low(LexerReportKind) .. high(LexerReportKind)}
  Report(category: repLexer, lexReport: rep)

func wrap*(rep: sink ParserReport): Report =
  assert rep.kind in {low(ParserReportKind) .. high(ParserReportKind)}
  Report(category: repParser, parserReport: rep)

func wrap*(rep: sink SemReport): Report =
  assert rep.kind in {low(SemReportKind) .. high(SemReportKind)}
  Report(category: repSem, semReport: rep)

func wrap*(rep: sink BackendReport): Report =
  assert rep.kind in {low(BackendReportKind) .. high(BackendReportKind)}
  Report(category: repBackend, backendReport: rep)

func wrap*(rep: sink CmdReport): Report =
  assert rep.kind in {low(CmdReportKind) .. high(CmdReportKind)}
  Report(category: repCmd, cmdReport: rep)

func wrap*(rep: sink DebugReport): Report =
  assert rep.kind in {low(DebugReportKind) .. high(DebugReportKind)}
  Report(category: repDebug, debugreport: rep)

func wrap*(rep: sink InternalReport): Report =
  assert rep.kind in {low(InternalReportKind) .. high(InternalReportKind)}
  Report(category: repInternal, internalReport: rep)

func wrap*(rep: sink ExternalReport): Report =
  assert rep.kind in {low(ExternalReportKind) .. high(ExternalReportKind)}
  Report(category: repExternal, externalReport: rep)

func wrap*[R: ReportTypes](rep: sink R, iinfo: InstantiationInfo): Report =
  var tmp = rep
  tmp.reportInst = toReportLinePoint(iinfo)
  return wrap(tmp)


func wrap*[R: ReportTypes](
    rep: sink R, iinfo, point: ReportLinePoint): Report =
  var tmp = rep
  tmp.reportInst = iinfo
  tmp.location = some(ReportLineInfo(isRange: false, lpoint: point))
  return wrap(tmp)

func wrap*[R: ReportTypes](
    rep: sink R, iinfo: InstantiationInfo, point: ReportLinePoint): Report =
  wrap(rep, toReportLinePoint(iinfo), point)

template wrap*(rep: ReportTypes): Report =
  wrap(rep, toReportLineInfo(instLoc()))

func `$`*(point: ReportLinePoint): string =
  point.file & "(" & $point.line & ", " & $point.col & ")"

func `$`*(lrange: ReportLineRange): string =
  lrange.file & "(" & $lrange.startLine & ", " & $lrange.startCol &
    ")-" & $lrange.endLine & ", " & $lrange.endCol

func `$`*(linfo: ReportLineInfo): string =
  if linfo.isRange: $linfo.lrange else: $linfo.lpoint


type
  ReportList* = object
    ## List of the accumulated reports. Used for various `sem*` reporting
    ## mostly, and in other places where report might be *generated*, but
    ## not guaranteed to be printed out.
    list: seq[Report]

func addReport*(list: var ReportList, report: Report): ReportId =
  ## Add report to the report list
  list.list.add report
  result = ReportId(uint32(list.list.high) + 1)

func addReport*[R: ReportTypes](list: var ReportList, report: R): ReportId =
  addReport(list, wrap(report))

func `==`*(id1, id2: ReportId): bool = uint32(id1) == uint32(id2)

func isEmpty*(id: ReportId): bool = id == emptyReportId

func `$`*(id: ReportId): string =
  if id.isEmpty:
    "<empty report id>"

  else:
    "<report-id-" & $uint32(id) & ">"

func getReport*(list: ReportList, id: ReportId): Report =
  ## Get report from the report list using it's id
  list.list[int(uint32(id)) - 1]


func actualType*(r: SemReport): PType = r.typeMismatch[0].actualType
func formalType*(r: SemReport): PType = r.typeMismatch[0].formalType
func symstr*(r: SemReport): string = r.sym.name.s
