## This module provides type definitions for all structured report entries
## that compiler can provide.
##
## Note that this module specifically does not import anything else from
## the compiler - by design it is supposed to be available in every other
## module (because almost any phase of the compiler can generate reports
## one way or another). By design report should contain as much information
## as possible and *never* be used for any conditional logic in the
## compiler - it is a final form of the output that can only be printed to
## the output (either via user-provided report hook implementation, or
## using one of the built-in ones)
##
## Not using compiler-specific types also allows this report to be easily
## reused by external tooling - custom error pretty-printers, test runners
## and so on.

import std/[options]

import ast_enums
export ast_enums, options.some

type
  ReportKind* = enum
    ## Kinds of the toplevel reports. Only dispatches on report topics,
    ## such as sem, parse, macro (for `echo` in compile-time code) and so
    ## on. Subdivision is based on different phases of the compiler
    ## operation, and not on report's state itself, as those are completely
    ## orthogonal to each other (lexer might provide errors and hints,
    ## parser can provide errors, hints and warnings)

    repParser
    repLexer ## Report generated by lexer - bad tokens, lines that are too
             ## long etc.

    repSem ## Report produced directly by semantic analysis - compilation
           ## errors, warnings and hints

    repCmd ## Report related to execution of the external command - start
           ## of the command, execution failure, succes and so on.

    repDebug ## Side channel for the compiler debug report. Sem expansion
             ## traces and other helper messages designed specifically to
             ## aid development of the compiler

    repInternal ## Reports constructed during hanling of the internal
                ## compilation errors. Separate from debugging reports
                ## since they always exist - ICE, internal fatal errors
                ## etc.

    repBackend ## Backend-specific reports.


  ReportLineRange* = object
    ## Report location expressed as a span of lines in the file
    file*: string
    startLine*, endline*: int
    startColumn*, endColumn*: int

  ReportLinePoint* = object
    ## Location expressed in terms of a single point in the file
    file*: string
    line*: int
    column*: int

  ReportLineInfo* = object
    case isRange*: bool
      of true:
        lrange*: ReportLineRange

      of false:
        rpoint*: ReportLinePoint

  ReportSeverity* = enum
    rsevDebug ## Internal compiler debug information

    rsevHint ## User-targeted hint
    rsevWarning ## User-targeted warnings
    rsevError ## User-targeted error

    rsevFatal
    rsevTrace ## Additional information about compiler actions - external
              ## commands mostly.


  ReportBase* = object of RootObj
    location*: Option[ReportLineInfo] ## Location associated with report.
    ## Some reports do not have any locations associated with them (most
    ## (but not all, due to `gorge`) of the external command executions,
    ## sem tracing etc). Some reports might have additional associated
    ## location information (view type sealing reasons) - those are handled
    ## on the per-report-kind basis.

    reportInst*: ReportLinePoint ## Information about instantiation location
    ## of the reports - present for all reports in order to track their
    ## origins.

type
  LexerReportKind* = enum
    rlexLineTooLong

    # ???? `syntaxes.nim` uses it
    rlexCodeBegin = "CodeBegin"
    rlexCodeEnd = "CodeEnd"


  LexerReport* = object of ReportBase
    kind*: LexerReportKind

const
  rlexHintKinds*: set[LexerReportKind] = {rlexLineTooLong}

func severity*(rep: LexerReport): ReportSeverity =
  case rep.kind:
    of rlexHintKinds: rsevHint
    else: rsevTrace

type
  ParserReportKind* = enum
    rparName = "Name" ## Linter report about used identifier

  ParserReport* = object of ReportBase
    kind*: ParserReportKind

const
  rparHintKinds: set[ParserReportKind] = {rparName}

func severity*(parser: ParserReport): ReportSeverity =
  case parser.kind:
    of rparHintKinds: rsevHint
    else: rsevTrace

type
  SemReportEntry* = object
    ## Entry mentioned in the sem report - type or procedure definition,
    ## macros, template or any similar construct. Used in reports like
    ## overload failures, "template/generic instantiation of" and such, to
    ## store information about entry referred to.
    name*: string ## Name of the reported entry
    declaredIn*: ReportLinePoint ## Location of the entry declaration
    kind*: TSymKind ## Kind of the reported entry

  SemReportType* = object
    typeStr*: string
    declaredIn*: ReportLinePoint
    lockLevel*: Option[int] ## Lock level of the procedure types
    callConv*: Option[TCallingConvention]

  SemRef* = object

  SemContextKind* = enum
    sckInstantiationOf
    sckInstantiationFrom

  SemContext* = object
    location*: ReportLinePoint
    case kind*: SemContextKind
      of sckInstantiationOf:
        entry*: SemReportEntry

      of sckInstantiationFrom:
        discard

  #[
    errIllFormedAstX
    errCannotOpenFile
    errXExpected
    errRstGridTableNotImplemented
    errRstMarkdownIllformedTable
    errRstNewSectionExpected
    errRstGeneralParseError
    errRstInvalidDirectiveX
    errRstInvalidField
    errRstFootnoteMismatch
    errProveInit  # deadcode
    errUser
    # warnings
    warnCannotOpenFile = "CannotOpenFile"
    warnOctalEscape = "OctalEscape"
    warnXIsNeverRead = "XIsNeverRead"
    warnXmightNotBeenInit = "XmightNotBeenInit"
    warnDeprecated = "Deprecated"
    warnConfigDeprecated = "ConfigDeprecated"
    warnDotLikeOps = "DotLikeOps"
    warnSmallLshouldNotBeUsed = "SmallLshouldNotBeUsed"
    warnUnknownMagic = "UnknownMagic"
    warnRstRedefinitionOfLabel = "RedefinitionOfLabel"
    warnRstUnknownSubstitutionX = "UnknownSubstitutionX"
    warnRstBrokenLink = "BrokenLink"
    warnRstLanguageXNotSupported = "LanguageXNotSupported"
    warnRstFieldXNotSupported = "FieldXNotSupported"
    warnRstStyle = "warnRstStyle"
    warnCommentXIgnored = "CommentXIgnored"
    warnTypelessParam = "TypelessParam"
    warnUseBase = "UseBase"
    warnWriteToForeignHeap = "WriteToForeignHeap"
    warnUnsafeCode = "UnsafeCode"
    warnUnusedImportX = "UnusedImport"
    warnInheritFromException = "InheritFromException"
    warnEachIdentIsTuple = "EachIdentIsTuple"
    warnUnsafeSetLen = "UnsafeSetLen"
    warnUnsafeDefault = "UnsafeDefault"
    warnProveInit = "ProveInit"
    warnProveField = "ProveField"
    warnProveIndex = "ProveIndex"
    warnUnreachableElse = "UnreachableElse"
    warnUnreachableCode = "UnreachableCode"
    warnStaticIndexCheck = "IndexCheck"
    warnGcUnsafe = "GcUnsafe"
    warnGcUnsafe2 = "GcUnsafe2"
    warnUninit = "Uninit"
    warnGcMem = "GcMem"
    warnDestructor = "Destructor"
    warnLockLevel = "LockLevel"
    warnResultShadowed = "ResultShadowed"
    warnInconsistentSpacing = "Spacing"
    warnCaseTransition = "CaseTransition"
    warnCycleCreated = "CycleCreated"
    warnObservableStores = "ObservableStores"
    warnStrictNotNil = "StrictNotNil"
    warnResultUsed = "ResultUsed"
    warnCannotOpen = "CannotOpen"
    warnFileChanged = "FileChanged"
    warnSuspiciousEnumConv = "EnumConv"
    warnAnyEnumConv = "AnyEnumConv"
    warnHoleEnumConv = "HoleEnumConv"
    warnCstringConv = "CStringConv"
    warnEffect = "Effect"
    warnUser = "User"
    # hints
    hintSuccess = "Success"
    hintSuccessX = "SuccessX"
    hintCC = "CC"
    hintLineTooLong = "LineTooLong"
  ]#

  SemReportKind* = enum
    # Semantic errors begin
    rsemUserError = "UserError" ## `{.error: }`

    rsemCustomError
    rsemCustomPrintMsgAndNodeError
      ## just like custom error, prints a message and renders wrongNode
    rsemRawTypeMismatchError

    rsemCustomUserError
      ## just like customer error, but reported as a errUser in msgs

    # Global Errors
    rsemCustomGlobalError
      ## just like custom error, but treat it like a "raise" and fast track the
      ## "graceful" abort of this compilation run, used by `errorreporting` to
      ## bridge into the existing `msgs.liMessage` and `msgs.handleError`.

    # Call
    rsemCallTypeMismatch
    rsemExpressionCannotBeCalled
    rsemWrongNumberOfArguments
    rsemAmbiguousCall
    rsemCallingConventionMismatch

    # ParameterTypeMismatch

    # Identifier Lookup
    rsemUndeclaredIdentifier
    rsemExpectedIdentifier
    rsemExpectedIdentifierInExpr

    # Object and Object Construction
    rsemFieldNotAccessible
      ## object field is not accessible
    rsemFieldAssignmentInvalid
      ## object field assignment invalid syntax
    rsemFieldOkButAssignedValueInvalid
      ## object field assignment, where the field name is ok, but value is not
    rsemObjectConstructorIncorrect
      ## one or more issues encountered with object constructor

    # General Type Checks
    rsemExpressionHasNoType
      ## an expression has not type or is ambiguous

    # Literals
    rsemIntLiteralExpected
      ## int literal node was expected, but got something else
    rsemStringLiteralExpected
      ## string literal node was expected, but got something else

    # Pragma
    rsemInvalidPragma
      ## suplied pragma is invalid
    rsemIllegalCustomPragma
      ## supplied pragma is not a legal custom pragma, and cannot be attached
    rsemNoReturnHasReturn
      ## a routine marked as no return, has a return type
    rsemImplicitPragmaError
      ## a symbol encountered an error when processing implicit pragmas, this
      ## should be applied to symbols and treated as a wrapper for the purposes
      ## of reporting. the original symbol is stored as the first argument
    rsemPragmaDynlibRequiresExportc
      ## much the same as `ImplicitPragmaError`, except it's a special case
      ## where dynlib pragma requires an importc pragma to exist on the same
      ## symbol
      ## xxx: pragmas shouldn't require each other, that's just bad design

    rsemWrappedError
      ## there is no meaningful error to construct, but there is an error
      ## further down the AST that invalidates the whole

    # end

    # Semantic warnings begin
    rsemUserWarning = "UserWarning" ## `{.warning: }`
    # end

    # Semantic hints begin
    rsemUserHint = "UserHint" ## `{.hint: .}` pragma encountereed
    rsemXDeclaredButNotUsed = "XDeclaredButNotUsed"
    rsemDuplicateModuleImport = "DuplicateModuleImport"
    rsemXCannotRaiseY = "XCannotRaiseY"
    rsemConvToBaseNotNeeded = "ConvToBaseNotNeeded"
    rsemConvFromXtoItselfNotNeeded = "ConvFromXtoItselfNotNeeded"

    rsemProcessing = "Processing" ## Processing module
    rsemProcessingStmt = "ProcessingStmt" ## Processing toplevel statement

    rsemExprAlwaysX = "ExprAlwaysX" ## Expression always evaluates to "X"
    rsemConditionAlwaysTrue = "CondTrue" ## Condition is always true
    rsemConditionAlwaysFalse = "CondFalse" ## Condition is always false

    rsemPattern = "Pattern" ## Term rewriting pattern has been triggered
    rsemCannotMakeSink ## Argument could not be turned into a sink
                       ## parameter. Generated once in the whole compiler
                       ## `sinkparameter_inference.nim`
    rsemCopiesToSink ## Passing data to the `sink` parameter still copies
                     ## due to control flow in the code

    hintGlobalVar = "GlobalVar" ## Track global variable declarations?

    rsemExpandMacro = "ExpandMacro" ## Trace macro expansion progress


    rsemUserRaw = "UserRaw" # REVIEW - Used in
    # `semcall.semOverloadedCall()` and `extccomp.getCompileCFileCmd()`.
    # Seems like this one should be removed, it spans multiple compiler
    # subsystems. Can't understand what it is doing.

    rsemExtendedContext = "ExtendedContext" ## Extended contextual
    ## information. Used in `ccgstmts.genStmts()` and
    ## `semexprs.semExprNoType()`
    rsemImplicitObjConv = "ImplicitObjConv"
    # end

  SemReport* = object of ReportBase
    context*: seq[SemContext]
    expression*: Option[string] ## Rendered string representation of the
                                ## expression in the report.
    case kind*: SemReportKind
      of rsemExpandMacro, rsemPattern:
        originalExpr*: string # REVIEW right now I simply store result of
        # the `renderTree` in these fields, which is probably acceptable
        # for now, but maybe it would make sense to store the whole AST
        # directly? Expand macros might also dump in different formats
        # (like lisp, tree or json).

      of rsemTypeMismatch:
        actualType*, wantedType*: SemReportType
        descriptionStr*: string
        procEffectsCompat*: EffectsCompat
        procCallMismatch*: set[ProcConvMismatch]

      else:
        discard

const
  rsemErrorKinds*: set[SemReportKind] = {rsemUserError}
  rsemWarningKinds* = {rsemUserWarning}
  rsemHintKinds* = {rsemUserHint .. rsemImplicitObjConv}

# static:
#   let all = (rsemErrorKinds + rsemWarningKinds + rsemHintKinds)
#   doAssert all == {low(SemReportKind) .. high(SemReportKind)},
#     "Not all sem report kinds are covered in the error/warning/hint groupings - " &
#       $(all - {low(SemReportKind) .. high(SemReportKind)}), " is missing"

func severity*(report: SemReport): ReportSeverity =
  case report.kind:
    of rsemErrorKinds: rsevError
    of rsemWarningKinds: rsevWarning
    of rsemHintKinds: rsevHint

type
  CmdReportKind* = enum
    rcmdTest

  CmdReport* = object of ReportBase
    kind*: CmdReportKind

func severity*(report: CmdReport): ReportSeverity =
  rsevTrace

type
  DebugReportKind* = enum
    rdbgTest

  DebugReport* = object of ReportBase
    kind*: DebugReportKind

func severity*(report: DebugReport): ReportSeverity =
  rsevDebug

type
  BackendReportKind* = enum
    rbackLinking
    rbackCompilingExtraFile ## Compiling file specified in the
    ## `{.compile:.}` pragma

    rbackUseDynLib ## Use of the dynamic library for cgen. Used in the
    ## `cgen.loadDynamicLib`


  BackendReport* = object
    kind*: BackendReportKind

func severity*(report: BackendReport): ReportSeverity =
  rsevTrace

type
  InternalReportKind* = enum
    # Fatal internal compilation errors begin
    rintUnknown ## Unknown internal report kind
    rintFatal ## Explicitly fatal compiler error
    rintIce ## Internal compilation error
    # end

    rintStackTrace = "StackTrace" ## Stack trace during internal
    ## compilation error handling and similar
    rintMissingStackTrace ## Stack trace would've been generated in the
    ## debug compiler build
    rintGCStats = "GCStats" ## Print GC statistics for the compiler run
    rintQuitCalled = "QuitCalled" ## `quit()` called by the macro code

    rintConf = "Conf" ## Processing user configutation file
    rintPath = "Path" ## Add nimble path


  InternalReport* = object of ReportBase
    ## Report generated for the internal compiler workings
    case kind*: InternalReportKind
      of rintStackTrace:
        trace*: seq[StackTraceEntry] ## Generated stack trace entries

      else:
        discard

const
  rintFatalKinds*: set[InternalReportKind] = {rintUnknown .. rintIce} ## Fatal internal compilation reports

func severity*(report: InternalReport): ReportSeverity =
  case report.kind:
    of rintFatalKinds: rsevFatal
    else: rsevTrace


type
  ReportTypes* =
    LexerReport    |
    ParserReport   |
    SemReport      |
    CmdReport      |
    DebugReport    |
    InternalReport |
    BackendReport


  ReportKindTypes* =
    LexerReportKind    |
    ParserReportKind   |
    SemReportKind      |
    CmdReportKind      |
    DebugReportKind    |
    InternalReportKind |
    BackendReportKind

  ReportKindSet* = object
    ## Group report kind categories into a single object.
    lex*:      set[LexerReportKind]
    parser*:   set[ParserReportKind]
    sem*:      set[SemReportKind]
    cmd*:      set[CmdReportKind]
    debug*:    set[DebugReportKind]
    internal*: set[InternalReportKind]
    backend*:  set[BackendReportKind]

  Report* = object
    ## Toplevel wrapper type for the compiler report
    case kind*: ReportKind
      of repLexer:
        lexReport*: LexerReport

      of repParser:
        parserReport*: ParserReport

      of repSem:
        semReport*: SemReport

      of repCmd:
        cmdReport*: CmdReport

      of repDebug:
        debugReport*: DebugReport

      of repInternal:
        internalReport*: InternalReport

      of repBackend:
        backendReport*: BackendReport

func contains*(rset: ReportKindSet, report: Report): bool =
  case report.kind:
    of repLexer:    report.lexReport.kind in rset.lex
    of repParser:   report.parserReport.kind in rset.parser
    of repCmd:      report.cmdReport.kind in rset.cmd
    of repSem:      report.semReport.kind in rset.sem
    of repDebug:    report.debugReport.kind in rset.debug
    of repInternal: report.internalReport.kind in rset.internal
    of repBackend:  report.backendReport.kind in rset.backend

template wrapSet(kind, field: untyped): untyped =
  func incl*(rset: var ReportKindSet, rep: kind | set[kind]) = rset.field.incl rep
  func excl*(rset: var ReportKindSet, rep: kind | set[kind]) = rset.field.excl rep
  func contains*(rset: ReportKindSet, rep: kind): bool = rep in rset.field
  func toReportKindSet*(rset: set[kind]): ReportKindSet =
    ReportKindSet(field: rset)


wrapSet(LexerReportKind, lex)
wrapSet(ParserReportKind, parser)
wrapSet(SemReportKind, sem)
wrapSet(CmdReportKind, cmd)
wrapSet(DebugReportKind, debug)
wrapSet(InternalReportKind, internal)
wrapSet(BackendReportKind, backend)

func toReportKindSet*(sets: varargs[])

func severity*(
    report: Report,
    asError: ReportKindSet = default(ReportKindSet),
    asWarning: ReportKindSet = default(ReportKindSet)
  ): ReportSeverity =
  ## Return report severity accounting for 'asError' and 'asWarning'
  ## mapping sets.

  if report in asError: rsevError
  elif report in asWarning: rsevWarning
  else:
    case report.kind:
      of repLexer:    report.lexReport.severity()
      of repParser:   report.parserReport.severity()
      of repSem:      report.semReport.severity()
      of repCmd:      report.cmdReport.severity()
      of repInternal: report.internalReport.severity()
      of repBackend:  report.backendReport.severity()
      of repDebug:    report.debugReport.severity()



func toReportLinePoint*(iinfo: (string, int, int)): ReportLinePoint =
  ReportLinePoint(file: iinfo[0], line: iinfo[1], column: iinfo[2])

template reportHere*[R: ReportTypes](report: R): R =
  block:
    var tmp = report
    tmp.reportInsta = toReportLinePoint(
      instantiationInfo(fullPaths = true))

    tmp

func wrap*(rep: sink LexerReport): Report =
  Report(kind: repLexer, lexReport: rep)

func wrap*(rep: sink ParserReport): Report =
  Report(kind: repParser, parserReport: rep)

func wrap*(rep: sink SemReport): Report =
  Report(kind: repSem, semReport: rep)

func wrap*(rep: sink CmdReport): Report =
  Report(kind: repCmd, cmdReport: rep)

func wrap*(rep: sink DebugReport): Report =
  Report(kind: repDebug, debugreport: rep)

func wrap*(rep: sink InternalReport): Report =
  Report(kind: repInternal, internalReport: rep)


type
  ReportId* = distinct uint32 ## Id of the report in the report list
  ReportList* = object
    ## List of the accumulated reports. Used for various `sem*` reporting
    ## mostly, and in other places where report might be *generated*, but
    ## not guaranteed to be printed out.
    list: seq[Report]

func addReport*(list: var ReportList, report: Report): ReportId =
  ## Add report to the report list
  list.list.add report
  result = ReportId(uint32(list.list.len))

func addReport*[R: ReportTypes](list: var ReportList, report: R): ReportId =
  addReport(list, wrap(report))

func getReport*(list: ReportList, id: ReportId): Report =
  ## Get report from the report list using it's id
  list.list[int(uint32(id) - 1)]
